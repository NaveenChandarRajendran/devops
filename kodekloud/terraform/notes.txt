-------------------------------------
IAC - Infrastructure as Code
-------------------------------------
    -> Write code to configure the cloud so that we dont want to go to management console and manually do the process.
    -> Start and end the process.

We can do this with shell script:
    We need to write the script and we can exceute the script anytime.
    But the script is hard to write and hard to automate.
    Thats why the terraform and Ansible are came to picture

-------------------------------------
Types of IAC Tools
-------------------------------------
Configuration Management Tools
    -> Ansible
    -> puppet
    -> saltstack

Server Template
    ->docker
    -> HashCorp Packer
    -> HashiCorp Vagrant

Provisioning Tools
    -> HashiCorp terraform
    -> CloudFOrmation

-------------------------------------
Configuration Management Tools
-------------------------------------
Designed to install and manage solutions
Maaintain Standard structure
The designed to run on multiple remote resourses at once.
Ansible playbook is used for version control repositaory
The most important feature is they are Idempotent
Idempotent means 
    -> You can run the code multiple times
    -> Every time you run, it will do only the nesessary steps to bring the environment stable.
    -> Ignore the already working code and dont need now to execute.

-------------------------------------
Server Template Tools
-------------------------------------
    -> Pre installed software and Depedency is avaiable
    -> Virtual Machine or Docker images will be avaiable to ready to use
    -> Immutable Infrastructure. As any changes to made , we need to create the new image and redeploy we cant update the exisitng images top of it.

-------------------------------------
Provisioning Tools
-------------------------------------
    -> Deploy Immutable Infrastructure resourses
    -> Servers,Databases,Network Components etx,
    -> Multiple Providers

-------------------------------------
Terraform
-------------------------------------    

It is single binary and open sourece.
very fast to create an process and work in multi clouds tech
Bigest advantage is that Terraform has abitlity to deploy multiple accross multiple platform
Terrform has many providers to make work the almost every Infrastructure platforms
The code which we write for terrform is HCL - HashiCorp Configuration Language.

The Terraform has 3 phases at exceution phases.
    -> Init
    -> Plan
    -> Apply

At start it it wll initalixe the project
It will plan what needs to be execute.
ex:
    in HCL we mentioned 3 instance means like aws_instance,aws_bucket,aws_aim_user
    It will plan what servcie needs to call.
After plan it will execute the plan

-------------------------------------
HCL Language
-------------------------------------
ex syntax is 

resource <providername> "resoucename" {
    key1 = value1
    key2 = value2
}

For local file resource we will write the config as 

resource "local_file" "pet" {
    filename = "/root/pets.txt"
    content = "We love pets"
}

the word "local_file" is the provider name we can get it from the terraform site,
"pet" is the name of the resouce which we can use anything
filename and content keys are the need to be used for the "local_file" provider.
some keys will mandatory some are optional here the filename is mandatory.

commands to execute
    -> terraform init (to initalize the setup based on the config)
    -> terraform plan (It will download the provider plugin and make plan to excute)
    -> terraform apply (To apply the planned context)
    -> terraform show (Used to seee the details)
    -> We can update the the config file and after update if you give terraform plan means it will show the changes as git changes.Then we can give terraform apply.It will delete the file and recreate it will the latest config.
    -> terraform destroy (to destory)


-------------------------------------
Input Variables
-------------------------------------
create new file as varible.tf

ex:

variable "filename"{
    default = "/root/pets/txt"
}

variable "content"{
    default = "We love pets"
}


in main.tf

resource "local_file" "pet" {
    filename = var.filename
    content = var.content
}

we can edit the variable any time and do terraform apply

-------------------------------------
Variables Block
-------------------------------------
    type and desctrition we can use in resource

string
variable "content"{
    default = "We love pets",
    type = string
    desctrition = sample //good to have
}
List
variable prefreix{
    type = list or list(string)
    default = ['Mr','Mrs']
    desctrition - sample
}

resource "local_file" "my-pet" {
    prefix = var.prefix[0]
}


Map

variable "file-content"{
    type = map
    default = {
        "statement 1" = "We love pets!"
        "statement 2" = "We love pets!"
    }
}

usesage:

resource "local_file" "my-pet" {
    filename = var.filename
    content = var.file-content["statement2"]
}

Set
Set is also same as list but in array we cant put the same value

ex:

variable prefix{
    type = set or set(string)
    default = ['Mr','Mrs'] -> good  default = ['Mr','Mrs','Mr']  -> bad not allowed
    desctrition - sample
}

Object

We can use our entire variables in a same object and refer

variable "bella" {
    type = object({
        name = string
        color = string
        age = number
        food = list(string)
        favrite_pet = bool
    })
}

Tuples

variable kitty{
    type = tuple([string,number,bool])
    default = ["cat",7,true]
} 

We cant give more than the tuple format 
ex:
Failed case
variable kitty{
    type = tuple([string,number,bool])
    default = ["cat",7,true]
}

-------------------------------------
Accessing variables in resource
-------------------------------------
Way 1
We can put variable as empty state like this
variable kitty{
} 

so now if we run terraform apply means 
in terminal it will prompt in that we can give the values

Way 2
in terraform apply command we can give like

terraform apply -var "filename=/root/pets.txt"
-var "contant=we love Pets"

by mentioning -var we can do as many variable and run

Way3

We also give value as env variables. followed by TF_VAR

Ex:
export TF_VAR_filename="/root/pets.txt"
export TF_VAR_content="We love pets"
export TF_VAR_prefix="Mrs"
terraform apply

Way4

we can create an seperate file for variable. the file must be in .tfvars

ex:
new file called terraform.tfvars

filename = "/root/pets.txt"
content = "We love pets"

terraform apply

If you create the variable file with terraform.tfvars means the terraform apply starightly work.

If you give custom name for variable means on apply you need to give file name

Ex:
terraform apply -var-file variable.tfvars

Variable Definition Precedence (Order of execution )

Imagine in all format we have variable files (Way1,2,3,4)

So terraform what will consider as value. in what order it will take?

Order
1 -> Environmanet Variables
2 -> terraform.tfvars
3 -> <anyfilename>.tfvars (alphabetical order)
4 -> -var or -var-file(comnined-line flags)


-------------------------------------
Resource Attribure Refrence
-------------------------------------
In real life the resouces mostly will be link to link each other means

one output of resouce needs to send to input of other resource.
Link/Chain will be there like functions in js returns

Every/some resource type has some return value.If we check in official docs we can see it in Attribute Refrence

Ex: the refereance randam_pet will return the pet name as [id=Mr.Bull]

so in tf file

resource "local_file" "pet"{
    filename = var.filename
    content : "My faverite pet is ${random_pet.my-pet.id}"
}

resouce "random_pet" "my-pet"{
    prefix = var.prefix
}


-------------------------------------
Implicit Dependency
-------------------------------------
resource "local_file" "pet"{
    filename = var.filename
    content : "My faverite pet is ${random_pet.my-pet.id}"
}

resouce "random_pet" "my-pet"{
    prefix = var.prefix
}

in the above resouce when terraform apply first creat the random_pet then create the local_file

when you destory the resouce, it will remove the local_file then randam_pet

The terraform will decide the depency according that is Implicit Dependency


-------------------------------------
Explicit Dependency
-------------------------------------
Image the local_file content does not refer to random_pet

ex:
resource "local_file" "pet"{
    filename = var.filename
    content : "My faverite pet is MR.Cat"
}

but still we can mention the order to excute before the local_file to excute by giving the depends_on =[]

Ex:
resource "local_file" "pet"{
    filename = var.filename
    content : "My faverite pet is MR.Cat"
    depends_on = [
        random_pet.my-pet
    ]
}

the depends_on is array we can give as many can

-------------------------------------
Output variables
-------------------------------------

We can store the return value of the resources

Ex:

output "pet-name"{
    value = random_pet.my-pet.id,
    desctrition = "mY fAVERITE pET nAME"
}

We can see the output values
terraform output
terraform output pet-name


-------------------------------------
Terraform State
-------------------------------------

When we will terraform apply means in the directory we will get terraform.tfstate.

this know the changes current state of the main file.

It is the blueprint by seeing that json we can get some knowlegde

-------------------------------------
Terraform Commands
-------------------------------------

terraform validate
    Before giving the plan or apply we can validate the file has correct syntax or not.
    It will returj as success

terraform fmt
    used to format tje file.Very usefull

terraform show
terraform refresh
terraform graph
    It will show our config in grapgh

-------------------------------------
Mutable and immutable Infrastucture
-------------------------------------
Mutable:
    Updrading the current software version

Non mutable:
    When we will terraform apply when you changed a thing in file means.It will create an another new config only.
    Everytime new config only will generate.

-------------------------------------
LifeCycle Rules
-------------------------------------
THe terraform will have the non mutable process as defaults
    -> But some case you dont have to be work like that.
    -> Sometime you need to create the updated config file before deleting the current config file
    -> Or Sometime you dont want to delete the current config itself

In this cases lifecycle rules will help.
The syntax for this is 
lifecycle {
    <rules> = boolean or list
}

create_before_destroy
    THis rule will generate the new config based on the changes and delete the old config file
ex:
lifecycle {
    create_before_destroy = true
}    

prevent_destroy:
    This ensure that no delete on the config

ignore_changes:
    IT will ignore the changes based on the some property of resources
    SO it accept as list
Ex:
resouce "aws_instance" "webserver"{
    ami ="ami-sdsadas"
    instantce_type = "tw.micro"
    tags = {
        Name = "ProjectA-webserver"
    }
    lifecycle{
        ignore_changes = [
            tags
        ]
    }
}
If does not consider the tag

-------------------------------------
Terraform with AWS IAM
-------------------------------------

IAM -> Identity access Management

resouce "aws_iam_user" ""admin-user"{
    name="lucy"
    tags = {
        Description = "Technical Lead"
    }
}

terraform plan -> will throw the error
error credential needs to provide
for this need to give aws provider

provider "aws"{
    region ="us-west-2"
    access_key = ""
    secret_key = ""
}


resouce "aws_iam_user" ""admin-user"{
    name="lucy"
    tags = {
        Description = "Technical Lead"
    }
}

now it will work

TO add the IAM Policy. we need to use the aws_iam_policy provider by giving the policy json

Ex:

resouce "aws_iam_policy" ""adminUser"{
    name="AdminUsers"
    policy = 
}

To provide the json we can create the seperate file as json and import here

Ex:
resouce "aws_iam_policy" ""adminUser"{
    name="AdminUsers"
    policy = file("admin-policy.json")
}

Full code of providing assecess is

resouce "aws_iam_user" ""admin-user"{
    name="lucy"
    tags = {
        Description = "Technical Lead"
    }
}
resouce "aws_iam_policy" ""adminUser"{
    name="AdminUsers"
    policy = file("admin-policy.json")
}
resouce "aws_iam_user_policy_attachment" "lucy-admin-access"{
    user = aws_iam_user-user.name
    policy_arn = aws_iam_policy.adminUser.arn
}

The aws_iam_user_policy_attachment is used to attach the aws policy certificate

-------------------------------------
Terraform with AWS S3
-------------------------------------

//To create the aws s3 bucket
resouce "aws_s3_bucket" "finance"{
    bukcet="fiance-20022026"
    tags = {
        Description = "FInancePayroll"
    }
}

//To store the files in AWS S3 cucket
resouce "aws_s3_bucket_object" "finance-2026"{
    content="/root/fiance-20022026"
    key = "finance-2026.doc"
    bucket = aws_s3_bucket.finance.id
}

//TO give permission to the user we need policy to access S3 bucket but what if already user group or manually in aws conosle management the user is created. for that we need to set the data to terraform.

data "aws_iam_group" "finance-data"{
    group_name = finance-analytics
}

By adding this , the terraform hae the user info in the ts.state file

//to give policy to the bucket

resouce "aws_s3_bucket_policy" "finance-policy"{
    bucket = aws_s3_bucket.fiance.id
    policy = <<EOF policy json>>
}

-------------------------------------
Remote State and State Locking
-------------------------------------

To keep the state.tf to any version control is risk, because it has sentitive data like password and ip address.

State Locking
    Image it two develpers are working in the same state.tf file and the state file is in remote  and trying to terraform apply means conflict come

DevOps Engineer 1          DevOps Engineer 2
      ‚Üì                          ‚Üì
terraform apply            terraform apply
      ‚Üì                          ‚Üì
creating 5 servers         deleting 3 servers
      ‚Üì                          ‚Üì
         CONFLICT! üí•
    terraform state file gets CORRUPTED


The State locking is not supported in git.
We need remote state backend.
We need to put the state file in remote backend. and whenever developers are doing terraform apply it save in the remote.
The backend will take care about the statelocking

Most Common Remote Backends in Industry:
AWS S3 + DynamoDB    ‚Üê most popular
Terraform Cloud      ‚Üê HashiCorp's own solution
Azure Blob Storage   ‚Üê for Azure teams
Google Cloud Storage ‚Üê for GCP teams

-------------------------------------
Terraform State Commands
-------------------------------------

TO edit state file we need to use the terraform state command not vi terraform.tfstate

EX:

the terraform state show aws_s3_bucket.finance
Syntax:
terraform state <subcommand> [options] [args]
The sub commands are 
    -> list
    -> mv
    -> pull
    -> remote
    -> show

list
* terraform state list
    It will show all the resource name which used in the main.tf file.
* terraform state list aws_s3_bucket.finance
    this list the mentioned resource name if present

show
* terraform state show aws_s3_bucket.finance
    IT will show details of the resource with arguments which passed to resources and everything

mv -(move)
* If we need to update the resouce name without recreating means we can use mv command
Ex:
syntax:
    terraform state mv [options] SOURCE DESTINATION

    terraform state mv aws_Dynamodb_table.state-locking aws_dynamodb_table.state-locking-db

    this makes the required update in the sstate file.

    So when we do terraform apply
    They wont be any new added or update of the file will be occurerd.

    But in the main.tf file we need to manuall edit the aws_Dynamodb_table.state-locking to aws_Dynamodb_table.state-locking-db

pull
    We see that state file will be present in the remote state not in our local system.

    for that we need to pull command.It will pull from the remote and show you the state file.

    terraform state pull

rm
    To remove the resouce we can use terraform state rm aws_Dynamodb_table.state-locking


-------------------------------------
Terraform AWS EC2
-------------------------------------

resource "aws_instance" "webserver"{
    ami = "ami-0edab...."
    instance_type = "t2.micro"
    tags = {
        Name = "webserver"
        Description = "An Ngnix Webserver on Ubuntu"
    }
    user_data = <<-EOF  
                sudo apt update
                suda apt i
}

provider "aws"{
    region = "us-west-1"
}

* By above command we can create the remote ec2 server but how to connect it form our local client.

    As every OS need to authentication before connection to the remove server

    if ubuntu means we need SSH key and value
    if windows means we need username and password

    For this we need to use aws_key_pair.web.id

    resouce "aws_key_pair" "web"{
        public_key = file("/root./ssh/web.pub")
    }

    then add a attribute called key_name in the above resouce like this
        key_name = aws_key_pair.web.id

* Then we need to add the IP Id in the ec2 instance for accessing it

    resouce "aws_security_group" "ssh-access"{
        name ="ssh-access"
        descriptiom = "Allow SSH access from the Internet"
        ingress {
            from_port = 22
            to_port = 22
            protocol = "tcp"
            cidr_blocks =["0.0.0.0/0"]
        }
    }

    After adding it we need to mention that in the main resource with attribute like below

    vpc_security_group_ids = [aws_security_group.ssh-access.id]

    Use put to see the public id so we can connect the instance in our system

    output publicip{
        value = aws_instance.webserver.publick_ip
    }


-------------------------------------
Terraform Taint
-------------------------------------

When we do the terraform apply if it crash, the crash resouce will be marked as tainted by terraform.

When ever we do terraform plan the tained resouce again will be created newly

But in some case we manually will do the taint command.
Ex:
    terraform taint aws_instance.webserver

    By this the resouce is made as taint when ever we do terraform plan the resource will create new

Why taint us usefull?
    If user changed any thing in EC2 in direct console means in terraform that will outdated. 

    In that cases when you want to update when you give terraform plan it will be automaticaaly create new resource so update thing will come

To untaint
    terraform untaint aws_instance.webserver

-------------------------------------
Terraform Debugging
-------------------------------------
To debug the terraform will export the logs in terms for five log levels
    -> info
    -> warning
    -> error
    -> debug
    -> trace

To export log in file use as
    export TF_LOG_PATH = /tmp/terraform.log

-------------------------------------
Terraform Import
-------------------------------------

The import is used when some sources are created by other methods like directly in aws statement and others tools like Ansible.

To get that other source to get control of terrafor, we need to use import.

Syntax:

terraform import <resouce_type>.<resource_name> <attribute>

When you run 1st time
    terraform import aws_instance.webserver-2 i-026e13....

You will get the error as, please create its configuration in rrot module,in order to fix this. We need to create an empty resourses

resouce "aws_instance" "web-server-2"{
    # ( resource arguments)
}

-------------------------------------
Terraform module
-------------------------------------

We can split the common resouce as seperate folders and use it here.

it will be used as 

module "<name>"{
    source ="./terraform-project"
}

There are two types of module 
    1.Local module (which we are created as per needs)
    2.Registry module(from hashicorp verified and community) we have some modulues which we can use it directly behind they will maintain the module sections
-------------------------------------
Terraform functions
-------------------------------------
Numberic functions
    min()
    max()
    ceil(10.1) -> 11
    ceil(10.9) -> 11
    floor(10.1) -> 10

String functions
    split(",", "ami-xyz","AMI_ABC","ami-efg")
    ["ami-xyz","AMI_ABC","ami-efg"]    

    lower(var.ami)
    ["ami-xyz","ami_abc","ami-efg"]

    upper(var.ami)
    [AMI-XYZ,"AMI_ABC","AMI-EFG"]

    title(var.ami)
    Ami-Xyz,AMI_ABC,Ami-efg

    substr(var.ami,0,7)
    ami-xyz

    join(",",  ["ami-xyz","AMI_ABC","ami-efg"])
    "ami-xyz","AMI_ABC","ami-efg"

collection functions
    length(var.ami)
    3

    index(var.ami, "AMI_ABC")
    1

    element(var.ami,2)
    ami-efg

    contains(var.ami,"AMI_ABC")
    true

Map functions
    


